---
- name: "Verificaci√≥n autom√°tica de servidores Linux - Handler Universal v5 Mejorado"
  hosts: localhost
  connection: local
  gather_facts: yes
  become: false
  vars:
    # Variables comunes de Dynatrace
    dynatrace_problem_id: "{{ dynatrace_problem_id | default('UNKNOWN') }}"
    dynatrace_problem_title: "{{ dynatrace_problem_title | default('Sin t√≠tulo') }}"
    dynatrace_problem_details: "{{ dynatrace_problem_details | default('Sin detalles') }}"
    dynatrace_state: "{{ dynatrace_state | default('UNKNOWN') }}"
    dynatrace_impact_level: "{{ dynatrace_impact_level | default('UNKNOWN') }}"
    aranda_case_id: "{{ aranda_case_id | default('') }}"
    aranda_case_number: "{{ aranda_case_number | default('') }}"
    affected_hosts: "{{ affected_hosts | default([]) }}"
    affected_services: "{{ affected_services | default([]) }}"
    webhook_timestamp: "{{ webhook_timestamp | default('') }}"
    problem_url: "{{ problem_url | default('') }}"
    
    # Detecci√≥n autom√°tica de fuente de datos
    data_source: "{{ data_source | default('auto') }}"
    
    # Variables normalizadas (se detectan autom√°ticamente)
    source_host_name: >-
      {%- if dynatrace_host_name is defined and dynatrace_host_name != "" -%}
        {{ dynatrace_host_name }}
      {%- elif zabbix_host_name is defined and zabbix_host_name != "" -%}
        {{ zabbix_host_name }}
      {%- else -%}
        unknown
      {%- endif -%}
    
    source_host_ip: >-
      {%- if dynatrace_host_ip is defined and dynatrace_host_ip != "" -%}
        {{ dynatrace_host_ip }}
      {%- elif zabbix_host_ip is defined and zabbix_host_ip != "" -%}
        {{ zabbix_host_ip }}
      {%- else -%}
        unknown
      {%- endif -%}
    
    detected_source: >-
      {%- if data_source != "auto" -%}
        {{ data_source }}
      {%- elif dynatrace_host_name is defined and dynatrace_host_name != "" -%}
        dynatrace
      {%- elif zabbix_host_name is defined and zabbix_host_name != "" -%}
        zabbix
      {%- else -%}
        unknown
      {%- endif -%}
    
    # Variables de configuraci√≥n
    check_timeout: 30
    retry_count: 3
    
  tasks:
    - name: "Detectar y normalizar fuente de datos"
      set_fact:
        normalized_vars:
          source: "{{ detected_source }}"
          host_name: "{{ source_host_name }}"
          host_ip: "{{ source_host_ip }}"
          problem_type: >-
            {%- if detected_source == "dynatrace" -%}
              {{ dynatrace_event_type | default('UNKNOWN') }}
            {%- elif detected_source == "zabbix" -%}
              {{ zabbix_trigger_name | default('UNKNOWN') }}
            {%- else -%}
              UNKNOWN
            {%- endif -%}
          severity: >-
            {%- if detected_source == "dynatrace" -%}
              {{ dynatrace_severity | default('UNKNOWN') }}
            {%- elif detected_source == "zabbix" -%}
              {{ zabbix_severity | default('UNKNOWN') }}
            {%- else -%}
              UNKNOWN
            {%- endif -%}
          metric_value: >-
            {%- if detected_source == "dynatrace" -%}
              {{ dynatrace_annotation | default('N/A') }}
            {%- elif detected_source == "zabbix" -%}
              {{ zabbix_item_value | default('N/A') }}
            {%- else -%}
              N/A
            {%- endif -%}

    - name: "Mostrar informaci√≥n del problema detectado"
      debug:
        msg: |
          ==============================================
          PROBLEMA DETECTADO - {{ normalized_vars.source | upper }}
          ==============================================
          ID del Problema: {{ dynatrace_problem_id }}
          T√≠tulo: {{ dynatrace_problem_title }}
          Estado: {{ dynatrace_state }}
          Nivel de Impacto: {{ dynatrace_impact_level }}
          URL del Problema: {{ problem_url }}
          
          FUENTE DE DATOS: {{ normalized_vars.source | upper }}
          Host: {{ normalized_vars.host_name }}
          IP del Host: {{ normalized_vars.host_ip }}
          Tipo de Problema: {{ normalized_vars.problem_type }}
          Severidad: {{ normalized_vars.severity }}
          M√©trica/Valor: {{ normalized_vars.metric_value }}
          
          {% if detected_source == "dynatrace" %}
          INFORMACI√ìN DYNATRACE:
          Event Type: {{ dynatrace_event_type | default('N/A') }}
          Annotation: {{ dynatrace_annotation | default('N/A') }}
          AWS Region: {{ aws_region | default('N/A') }}
          AWS AZ: {{ aws_availability_zone | default('N/A') }}
          AWS Resource ID: {{ aws_resource_id | default('N/A') }}
          {% elif detected_source == "zabbix" %}
          INFORMACI√ìN ZABBIX:
          Trigger: {{ zabbix_trigger_name | default('N/A') }}
          Item Key: {{ zabbix_item_key | default('N/A') }}
          Valor Actual: {{ zabbix_item_value | default('N/A') }}
          Event ID: {{ zabbix_event_id | default('N/A') }}
          {% endif %}
          
          HOSTS Y SERVICIOS:
          Hosts Afectados: {{ affected_hosts | join(', ') if affected_hosts else 'Detectado: ' + normalized_vars.host_name }}
          Servicios Afectados: {{ affected_services | join(', ') if affected_services else 'Ninguno' }}
          
          CASO ARANDA: {{ aranda_case_number }}
          Timestamp: {{ webhook_timestamp }}
          ==============================================

    - name: "Validar datos m√≠nimos requeridos"
      assert:
        that:
          - normalized_vars.host_name != "unknown"
          - normalized_vars.host_ip != "unknown"
          - normalized_vars.source in ["dynatrace", "zabbix"]
        fail_msg: |
          ERROR: Datos insuficientes para proceder
          Host name: {{ normalized_vars.host_name }}
          Host IP: {{ normalized_vars.host_ip }}
          Source: {{ normalized_vars.source }}
        success_msg: "‚úÖ Datos validados correctamente - Fuente: {{ normalized_vars.source | upper }}"

    - name: "Agregar host din√°micamente al inventario con clave SSH"
      add_host:
        name: "{{ normalized_vars.host_name }}"
        ansible_host: "{{ normalized_vars.host_ip }}"
        ansible_user: "{{ target_ssh_user | default('ansible-user') }}"
        ansible_ssh_private_key_file: "{{ ssh_private_key_path | default('/home/ec2-user/keyPairLNX-Shared.pem') }}"
        ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
        groups: 
          - dynamic_hosts
          - "{{ normalized_vars.source }}_monitored"
          - "problem_{{ dynatrace_problem_id | default('unknown') }}"
      when: 
        - normalized_vars.host_name != "unknown"
        - normalized_vars.host_ip != "unknown"

    - name: "Verificar conectividad al host objetivo"
      ping:
      delegate_to: "{{ normalized_vars.host_name }}"
      register: ping_result
      ignore_errors: yes
      when: normalized_vars.host_name != "unknown"

    - name: "Mostrar resultado de conectividad"
      debug:
        msg: |
          üîó CONECTIVIDAD AL HOST OBJETIVO:
          Host: {{ normalized_vars.host_name }} ({{ normalized_vars.host_ip }})
          Resultado: {{ 'EXITOSO ‚úÖ' if ping_result.ping is defined else 'FALLIDO ‚ùå' }}
          {% if ping_result.ping is not defined %}
          Error: {{ ping_result.msg | default('Timeout o error de conexi√≥n') }}
          {% endif %}

    - name: "Establecer host objetivo para el siguiente play"
      set_fact:
        target_host_for_checks: "{{ normalized_vars.host_name }}"
      when: ping_result.ping is defined

# PLAY 2: Verificaciones en el servidor objetivo (SIN SUDO)
- name: "Verificaciones en el servidor objetivo"
  hosts: "{{ hostvars['localhost']['target_host_for_checks'] | default('localhost') }}"
  gather_facts: yes
  become: false  # CAMBIADO: No usar sudo por defecto
  vars:
    # Reutilizar variables del play anterior
    dynatrace_problem_id: "{{ dynatrace_problem_id | default('UNKNOWN') }}"
    dynatrace_problem_title: "{{ dynatrace_problem_title | default('Sin t√≠tulo') }}"
    dynatrace_state: "{{ dynatrace_state | default('UNKNOWN') }}"
    dynatrace_impact_level: "{{ dynatrace_impact_level | default('UNKNOWN') }}"
    aranda_case_number: "{{ aranda_case_number | default('') }}"
    
  tasks:
    - name: "Verificar que estamos en el host correcto"
      debug:
        msg: |
          üéØ VERIFICACI√ìN DE HOST ACTUAL:
          ==============================================
          Host de Ansible: {{ inventory_hostname }}
          IP Real: {{ ansible_default_ipv4.address | default('N/A') }}
          Sistema Operativo: {{ ansible_distribution | default('N/A') }} {{ ansible_distribution_version | default('') }}
          Arquitectura: {{ ansible_architecture | default('N/A') }}
          Kernel: {{ ansible_kernel | default('N/A') }}
          Usuario actual: {{ ansible_user_id | default('N/A') }}
          ==============================================
          ‚úÖ Confirmaci√≥n: Ejecut√°ndose en el host remoto (no en localhost)

    - name: "Heredar variables normalizadas del play anterior"
      set_fact:
        inherited_vars: "{{ hostvars['localhost']['normalized_vars'] }}"
      when: hostvars['localhost']['normalized_vars'] is defined

    # TAREAS QUE NO REQUIEREN SUDO
    - name: "Verificar uso de CPU actual (sin sudo) - Mejorado"
      shell: |
        echo "=== AN√ÅLISIS DE CPU ==="
        
        # M√©todo 1: Load Average (siempre disponible)
        if [ -f /proc/loadavg ]; then
          echo "Load Average: $(cat /proc/loadavg | awk '{print $1, $2, $3}')"
        fi
        
        # M√©todo 2: CPU percentage desde /proc/stat
        if [ -f /proc/stat ]; then
          # Leer dos veces con un intervalo para calcular porcentaje real
          cpu1=$(awk '/^cpu / {print $2+$3+$4+$5+$6+$7+$8}' /proc/stat)
          idle1=$(awk '/^cpu / {print $5}' /proc/stat)
          sleep 1
          cpu2=$(awk '/^cpu / {print $2+$3+$4+$5+$6+$7+$8}' /proc/stat)
          idle2=$(awk '/^cpu / {print $5}' /proc/stat)
          
          cpu_delta=$((cpu2 - cpu1))
          idle_delta=$((idle2 - idle1))
          
          if [ $cpu_delta -gt 0 ]; then
            cpu_usage=$((100 * (cpu_delta - idle_delta) / cpu_delta))
            echo "CPU Usage (calculated): ${cpu_usage}%"
          else
            echo "CPU Usage: Unable to calculate"
          fi
        fi
        
        # M√©todo 3: Top command (puede fallar)
        if command -v top >/dev/null 2>&1; then
          top_output=$(timeout 3 top -bn1 | grep -i "cpu" | head -1 2>/dev/null || echo "Top command failed")
          echo "Top Output: $top_output"
        fi
        
        # M√©todo 4: Uptime para contexto
        if command -v uptime >/dev/null 2>&1; then
          echo "Uptime: $(uptime)"
        fi
      register: cpu_usage_result
      ignore_errors: yes

    - name: "Verificar uso de memoria actual (sin sudo)"
      shell: |
        if command -v free >/dev/null 2>&1; then
          free -m | awk 'NR==2{printf "%.2f%% (%d/%d MB)", $3*100/$2, $3, $2}' 2>/dev/null || echo "N/A"
        elif [ -f /proc/meminfo ]; then
          awk '/MemTotal/ {total=$2} /MemAvailable/ {avail=$2} END {used=total-avail; printf "%.2f%% (%d/%d MB)", used*100/total, used/1024, total/1024}' /proc/meminfo 2>/dev/null || echo "N/A"
        else
          echo "No memory monitoring tools available"
        fi
      register: memory_usage_result
      ignore_errors: yes

    - name: "Verificar uso de disco actual (sin sudo)"
      shell: |
        if command -v df >/dev/null 2>&1; then
          df -h / 2>/dev/null | awk 'NR==2{print $5 " (" $3 "/" $2 ")"}' || \
          df / 2>/dev/null | awk 'NR==2{printf "%.1f%% (%d/%d KB)", $3*100/$2, $3, $2}' || echo "N/A"
        else
          echo "df command not available"
        fi
      register: disk_usage_result
      ignore_errors: yes

    - name: "Verificar carga del sistema actual (sin sudo)"
      shell: |
        if command -v uptime >/dev/null 2>&1; then
          uptime | awk -F'load average:' '{print $2}' 2>/dev/null || echo "N/A"
        elif [ -f /proc/loadavg ]; then
          echo "$(cat /proc/loadavg | awk '{print $1, $2, $3}')"
        else
          echo "Load average not available"
        fi
      register: load_average_result
      ignore_errors: yes

    - name: "Verificar logs recientes del sistema (sin sudo cuando sea posible)"
      shell: |
        if command -v journalctl >/dev/null 2>&1; then
          # Intentar con journalctl (puede requerir permisos)
          journalctl --since="5 minutes ago" --priority=err --no-pager -q 2>/dev/null | head -10 || \
          # Fallback a logs de usuario
          journalctl --user --since="5 minutes ago" --no-pager -q 2>/dev/null | head -5 || \
          echo "Limited log access"
        elif [ -r /var/log/syslog ]; then
          tail -20 /var/log/syslog 2>/dev/null | grep -i error | head -5 || echo "No syslog errors found"
        elif [ -r /var/log/messages ]; then
          tail -20 /var/log/messages 2>/dev/null | grep -i error | head -5 || echo "No log errors found"
        else
          echo "No accessible log files found"
        fi
      register: system_logs_result
      ignore_errors: yes

    - name: "Verificar servicios accesibles sin sudo"
      shell: |
        # Verificar servicios que el usuario puede consultar
        if command -v systemctl >/dev/null 2>&1; then
          echo "=== SERVICIOS DISPONIBLES (sin sudo) ==="
          systemctl --user list-units --type=service --state=running 2>/dev/null | head -10 || \
          systemctl list-units --type=service --state=running --no-pager 2>/dev/null | head -10 || \
          echo "Limited service access"
        else
          echo "systemctl not available"
        fi
        
        # Verificar procesos del usuario
        echo "=== PROCESOS DEL USUARIO ==="
        if command -v ps >/dev/null 2>&1; then
          ps aux | grep "^$(whoami)" | head -5 2>/dev/null || echo "Limited process access"
        fi
      register: services_check
      ignore_errors: yes

    - name: "Verificar m√©trica espec√≠fica seg√∫n fuente (sin sudo)"
      shell: |
        {% if inherited_vars is defined and inherited_vars.source == "zabbix" %}
        case "{{ hostvars['localhost']['zabbix_item_key'] | default('') }}" in
          "system.cpu.util"*)
            if [ -f /proc/loadavg ]; then
              echo "Load Average: $(cat /proc/loadavg | awk '{print $1, $2, $3}')"
            else
              echo "Load average not available"
            fi
            ;;
          "vm.memory.size"*)
            if command -v free >/dev/null 2>&1; then
              free -m | awk 'NR==2{printf "Memory: Used %.2f%% (%d/%d MB)\n", $3*100/$2, $3, $2}' 2>/dev/null
            elif [ -f /proc/meminfo ]; then
              awk '/MemTotal/ {total=$2} /MemAvailable/ {avail=$2} END {used=total-avail; printf "Memory: Used %.2f%% (%d/%d MB)\n", used*100/total, used/1024, total/1024}' /proc/meminfo
            else
              echo "Memory info not available"
            fi
            ;;
          "vfs.fs.size"*)
            if command -v df >/dev/null 2>&1; then
              df -h / | awk 'NR==2{printf "Disk: %s used of %s (%s)\n", $3, $2, $5}' 2>/dev/null
            else
              echo "Disk info not available"
            fi
            ;;
          *)
            echo "M√©trica Zabbix: {{ hostvars['localhost']['zabbix_item_key'] | default('N/A') }}"
            ;;
        esac
        {% elif inherited_vars is defined and inherited_vars.source == "dynatrace" %}
        case "{{ hostvars['localhost']['dynatrace_event_type'] | default('') }}" in
          "CPU_SATURATED"*)
            echo "CPU Load Check: $(cat /proc/loadavg 2>/dev/null | awk '{print $1 " " $2 " " $3}' || echo 'N/A')"
            ;;
          "MEMORY_SATURATED"*)
            if command -v free >/dev/null 2>&1; then
              free -m | awk 'NR==2{printf "Memory: Used %.2f%% (%d/%d MB)\n", $3*100/$2, $3, $2}' 2>/dev/null
            else
              echo "Memory info not available"
            fi
            ;;
          "DISK_*"*)
            if command -v df >/dev/null 2>&1; then
              df -h / | awk 'NR==2{printf "Disk: %s used of %s (%s)\n", $3, $2, $5}' 2>/dev/null
            else
              echo "Disk info not available"
            fi
            ;;
          *)
            echo "Evento Dynatrace: {{ hostvars['localhost']['dynatrace_event_type'] | default('N/A') }}"
            ;;
        esac
        {% else %}
        echo "Fuente desconocida para verificaci√≥n de m√©trica"
        {% endif %}
      register: source_metric_check
      ignore_errors: yes

    - name: "Obtener lista de procesos (sin sudo)"
      shell: |
        if command -v ps >/dev/null 2>&1; then
          echo "=== TOP PROCESOS POR CPU ==="
          ps aux --sort=-%cpu 2>/dev/null | head -10 || ps aux | head -10
          echo ""
          echo "=== TOP PROCESOS POR MEMORIA ==="
          ps aux --sort=-%mem 2>/dev/null | head -5 || echo "Limited process access"
        elif [ -d /proc ]; then
          echo "Procesos activos (usando /proc):"
          ls /proc/[0-9]* -d 2>/dev/null | head -10 | while read dir; do
            if [ -f "$dir/comm" ] && [ -f "$dir/stat" ]; then
              comm=$(cat "$dir/comm" 2>/dev/null)
              echo "$(basename $dir): $comm"
            fi
          done
        else
          echo "No process monitoring tools available"
        fi
      register: processes_check
      ignore_errors: yes

    - name: "Verificar datos hist√≥ricos disponibles"
      shell: |
        echo "=== VERIFICACI√ìN DE DATOS HIST√ìRICOS ==="
        
        # Verificar si sar est√° disponible
        if command -v sar >/dev/null 2>&1; then
          echo "SAR disponible - Verificando datos hist√≥ricos de CPU:"
          # Intentar obtener datos de CPU de las √∫ltimas horas
          sar -u 1 1 2>/dev/null || echo "No se pudo ejecutar sar"
          
          # Verificar si hay archivos de estad√≠sticas
          if [ -d /var/log/sysstat ] && [ "$(ls -A /var/log/sysstat 2>/dev/null)" ]; then
            echo "Archivos de estad√≠sticas encontrados en /var/log/sysstat"
            ls -la /var/log/sysstat/ | head -5
          else
            echo "No se encontraron archivos hist√≥ricos de sysstat"
          fi
        else
          echo "SAR no est√° disponible"
        fi
        
        # Verificar uptime y √∫ltima vez que se reinici√≥
        echo ""
        echo "INFORMACI√ìN DE SISTEMA:"
        echo "Uptime actual: $(uptime)"
        echo "√öltimo reinicio: $(who -b 2>/dev/null || echo 'No disponible')"
        
        # Verificar si hay archivos de log con timestamps recientes
        echo ""
        echo "LOGS DISPONIBLES:"
        for log_file in /var/log/syslog /var/log/messages /var/log/kern.log; do
          if [ -r "$log_file" ]; then
            echo "$log_file: Accesible"
          else
            echo "$log_file: No accesible"
          fi
        done
      register: historical_data_result
      ignore_errors: yes
      shell: |
        echo "=== AN√ÅLISIS DE PROBLEMA REPORTADO VS ESTADO ACTUAL ==="
        echo "Problema original (Zabbix): {{ inherited_vars.metric_value }}% CPU utilization"
        echo "Timestamp del problema: {{ hostvars['localhost']['webhook_timestamp'] | default('No disponible') }}"
        echo "Timestamp actual: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo ""
        echo "Estado actual del sistema:"
        current_load=$(cat /proc/loadavg | awk '{print $1}')
        echo "Load Average actual: $current_load"
        
        # An√°lisis comparativo
        if [ "$(echo "$current_load < 1.0" | bc -l 2>/dev/null)" = "1" ] || [ "$(printf "%.0f" "$current_load" 2>/dev/null)" = "0" ]; then
          echo "AN√ÅLISIS: El sistema actualmente tiene carga BAJA"
          echo "CONCLUSI√ìN: El problema de CPU alta parece haberse RESUELTO"
          echo "POSIBLES CAUSAS del problema original:"
          echo "  - Proceso temporal que consumi√≥ CPU y ya termin√≥"
          echo "  - Pico de tr√°fico que ya disminuy√≥"
          echo "  - Tarea programada (cron) que ya complet√≥"
          echo "  - Reinicio de servicios que caus√≥ pico temporal"
        else
          echo "AN√ÅLISIS: El sistema A√öN tiene carga elevada"
          echo "CONCLUSI√ìN: El problema puede PERSISTIR"
        fi
        
        echo ""
        echo "RECOMENDACI√ìN: Revisar logs de tiempo del problema original para identificar la causa ra√≠z"
      register: problem_analysis_result
      ignore_errors: yes
      debug:
        msg: |
          ==============================================
          REPORTE DE DIAGN√ìSTICO AUTOM√ÅTICO (NO-SUDO)
          ==============================================
          Problema ID: {{ dynatrace_problem_id }}
          Caso Aranda: {{ aranda_case_number }}
          Fuente: {{ inherited_vars.source | upper if inherited_vars is defined else 'UNKNOWN' }}
          
          HOST VERIFICADO: {{ inventory_hostname }}
          -----------------------------------------------
          Conectividad: ‚úÖ OK
          Sistema Operativo: {{ ansible_distribution }} {{ ansible_distribution_version }}
          Arquitectura: {{ ansible_architecture }}
          Kernel: {{ ansible_kernel }}
          IP: {{ ansible_default_ipv4.address | default('N/A') }}
          Usuario: {{ ansible_user_id | default('N/A') }}
          
          M√âTRICAS DEL SISTEMA (acceso limitado):
          CPU Usage: {{ cpu_usage_result.stdout | default('N/A') }}
          Memory Usage: {{ memory_usage_result.stdout | default('N/A') }}
          Disk Usage: {{ disk_usage_result.stdout | default('N/A') }}
          Load Average: {{ load_average_result.stdout | default('N/A') }}
          
          M√âTRICA ESPEC√çFICA ({{ inherited_vars.source | upper if inherited_vars is defined else 'UNKNOWN' }}):
          {% if inherited_vars is defined %}
          Tipo/Key: {{ inherited_vars.problem_type }}
          Valor Reportado: {{ inherited_vars.metric_value }}
          {% endif %}
          {% if source_metric_check is defined and source_metric_check.stdout %}
          Verificaci√≥n Local: {{ source_metric_check.stdout }}
          {% endif %}
          
          SERVICIOS Y PROCESOS:
          {{ services_check.stdout | default('N/A') }}
          
          PROCESOS PRINCIPALES:
          {{ processes_check.stdout | default('N/A') }}
          
          LOGS DEL SISTEMA (acceso limitado):
          {% if system_logs_result.stdout %}
          {{ system_logs_result.stdout }}
          {% else %}
          Acceso limitado a logs del sistema
          {% endif %}
          ==============================================

    - name: "Intentar acciones de remediaci√≥n b√°sicas (sin sudo)"
      block:
        - name: "Limpiar archivos temporales del usuario"
          shell: |
            # Limpiar temp files del usuario actual
            find ~/tmp -type f -atime +7 -delete 2>/dev/null || true
            find /tmp -user $(whoami) -type f -atime +7 -delete 2>/dev/null || true
            echo "Limpieza de archivos temporales del usuario completada"
          ignore_errors: yes

        - name: "Verificar y reportar estado del sistema"
          shell: |
            echo "=== INFORMACI√ìN ADICIONAL DEL SISTEMA ==="
            echo "Uptime: $(uptime 2>/dev/null || echo 'N/A')"
            echo "Espacio en directorio home: $(du -sh ~ 2>/dev/null | awk '{print $1}' || echo 'N/A')"
            echo "Archivos abiertos por el usuario: $(lsof 2>/dev/null | grep $(whoami) | wc -l || echo 'N/A')"
            if [ -f /proc/version ]; then
              echo "Kernel version: $(cat /proc/version)"
            fi
          register: system_info_result
          ignore_errors: yes

        - name: "Mostrar resultado de acciones de remediaci√≥n"
          debug:
            msg: |
              üîß ACCIONES DE REMEDIACI√ìN COMPLETADAS (SIN SUDO):
              -----------------------------------------------
              ‚úÖ Limpieza de archivos temporales del usuario
              ‚úÖ Verificaci√≥n de estado del sistema
              
              INFORMACI√ìN ADICIONAL:
              {{ system_info_result.stdout | default('N/A') }}

      rescue:
        - name: "Log de error en remediaci√≥n"
          debug:
            msg: "‚ö†Ô∏è Error ejecutando acciones de remediaci√≥n: {{ ansible_failed_result.msg | default('Error desconocido') }}"

# PLAY 3: Reporte final desde localhost
- name: "Generar reporte final"
  hosts: localhost
  connection: local
  gather_facts: yes
  become: false
  vars:
    dynatrace_problem_id: "{{ dynatrace_problem_id | default('UNKNOWN') }}"
    dynatrace_problem_title: "{{ dynatrace_problem_title | default('Sin t√≠tulo') }}"
    dynatrace_state: "{{ dynatrace_state | default('UNKNOWN') }}"
    aranda_case_number: "{{ aranda_case_number | default('') }}"
    
  tasks:
    - name: "Generar reporte final y recomendaciones"
      debug:
        msg: |
          ==============================================
          üéØ REPORTE FINAL - AUTOMATIZACI√ìN COMPLETADA
          ==============================================
          Problema ID: {{ dynatrace_problem_id }} - {{ dynatrace_problem_title }}
          Caso Aranda: {{ aranda_case_number }}
          Estado del Problema: {{ dynatrace_state }}
          Fuente: {{ normalized_vars.source | upper }}
          Modo de ejecuci√≥n: SIN PRIVILEGIOS SUDO
          
          HOST VERIFICADO: {{ normalized_vars.host_name }} ({{ normalized_vars.host_ip }})
          
          ACCIONES REALIZADAS:
          ‚úÖ Verificaci√≥n de conectividad remota con clave SSH
          ‚úÖ Monitoreo de recursos en host objetivo (sin sudo)
          ‚úÖ Revisi√≥n de logs accesibles del sistema
          ‚úÖ Limpieza de archivos temporales del usuario
          ‚úÖ Verificaci√≥n espec√≠fica para {{ normalized_vars.source | upper }}
          ‚úÖ An√°lisis de procesos del usuario
          
          LIMITACIONES DEL MODO SIN SUDO:
          ‚ö†Ô∏è Acceso limitado a logs del sistema
          ‚ö†Ô∏è No se pueden consultar todos los servicios
          ‚ö†Ô∏è Acceso restringido a m√©tricas del sistema
          
          RECOMENDACIONES ESPEC√çFICAS:
          {% if normalized_vars.source == "dynatrace" %}
          - Revisar el dashboard de Dynatrace para m√©tricas actualizadas
          - Verificar AWS CloudWatch para m√©tricas adicionales
          - Considerar escalamiento autom√°tico en AWS si est√° disponible
          {% elif normalized_vars.source == "zabbix" %}
          - Revisar el dashboard de Zabbix para m√©tricas actualizadas y tendencias hist√≥ricas
          - Verificar triggers relacionados y su configuraci√≥n de thresholds
          - Analizar gr√°ficos de Zabbix del momento exacto del problema ({{ webhook_timestamp }})
          - Considerar ajustar la sensibilidad del trigger si fueron picos temporales normales
          {% endif %}
          
          ACCIONES RECOMENDADAS BASADAS EN EL AN√ÅLISIS:
          {% if "'RESUELTO'" in (problem_analysis_result.stdout | default('')) %}
          ‚úÖ PROBLEMA APARENTEMENTE RESUELTO:
          - Monitorear el sistema en las pr√≥ximas horas para confirmar estabilidad
          - Revisar si hay patrones horarios (ej: tareas cron, backups, etc.)
          - Documentar la resoluci√≥n autom√°tica para futura referencia
          - Considerar ajustar thresholds si son demasiado sensibles
          {% else %}
          ‚ö†Ô∏è PROBLEMA PUEDE PERSISTIR:
          - Investigaci√≥n inmediata requerida
          - Verificar procesos en ejecuci√≥n manualmente
          - Revisar aplicaciones cr√≠ticas
          - Considerar escalamiento a personal t√©cnico
          {% endif %}
          
          PR√ìXIMOS PASOS PARA CASO ARANDA {{ aranda_case_number }}:
          {% if "'RESUELTO'" in (hostvars[normalized_vars.host_name]['problem_analysis_result']['stdout'] | default('')) %}
          1. ACTUALIZAR CASO: "Problema de CPU alta se resolvi√≥ autom√°ticamente"
          2. ADJUNTAR: Este reporte de diagn√≥stico autom√°tico
          3. MONITOREAR: Sistema por 2-4 horas para confirmar estabilidad
          4. CERRAR: Caso si no hay recurrencia
          5. DOCUMENTAR: Resoluci√≥n para casos similares futuros
          {% else %}
          1. ESCALAR: Caso a nivel t√©cnico para investigaci√≥n inmediata
          2. ADJUNTAR: Este reporte como diagn√≥stico inicial
          3. INVESTIGAR: Procesos y aplicaciones manualmente
          4. IMPLEMENTAR: Acciones correctivas espec√≠ficas
          5. SEGUIMIENTO: Continuo hasta resoluci√≥n confirmada
          {% endif %}
          
          MEJORAS T√âCNICAS SUGERIDAS:
          - Configurar sudo sin contrase√±a para diagn√≥sticos m√°s completos
          - Instalar herramientas de monitoreo hist√≥rico (sysstat/sar)
          - Implementar alertas proactivas antes de que lleguen a thresholds cr√≠ticos
          - Crear scripts de diagn√≥stico autom√°tico m√°s detallados
          
          Ejecuci√≥n completada a las: {{ ansible_date_time.iso8601 | default(ansible_date_time.epoch) }}
          ==============================================

    - name: "Crear archivo de reporte universal (sin sudo)"
      copy:
        content: |
          REPORTE DE AUTOMATIZACI√ìN - UNIVERSAL PROBLEM HANDLER (NO-SUDO MODE)
          ====================================================================
          Timestamp: {{ ansible_date_time.iso8601 | default('N/A') }}
          Problema ID: {{ dynatrace_problem_id }}
          T√≠tulo: {{ dynatrace_problem_title }}
          Estado: {{ dynatrace_state }}
          Caso Aranda: {{ aranda_case_number }}
          Fuente de Datos: {{ normalized_vars.source | upper }}
          Modo de Ejecuci√≥n: SIN PRIVILEGIOS SUDO
          
          Host Verificado: {{ normalized_vars.host_name | default('N/A') }}
          Host IP: {{ normalized_vars.host_ip | default('N/A') }}
          Tipo de Problema: {{ normalized_vars.problem_type | default('N/A') }}
          M√©trica/Valor: {{ normalized_vars.metric_value | default('N/A') }}
          
          {% if normalized_vars.source == "dynatrace" %}
          INFORMACI√ìN DYNATRACE:
          Event Type: {{ dynatrace_event_type | default('N/A') }}
          AWS Region: {{ aws_region | default('N/A') }}
          AWS AZ: {{ aws_availability_zone | default('N/A') }}
          AWS Resource: {{ aws_resource_id | default('N/A') }}
          {% elif normalized_vars.source == "zabbix" %}
          INFORMACI√ìN ZABBIX:
          Trigger: {{ zabbix_trigger_name | default('N/A') }}
          Item Key: {{ zabbix_item_key | default('N/A') }}
          Event ID: {{ zabbix_event_id | default('N/A') }}
          {% endif %}
          
          VERIFICACI√ìN REALIZADA EN HOST REMOTO: {{ normalized_vars.host_name }}
          
          CONFIGURACI√ìN DE CONEXI√ìN:
          - Usuario SSH: {{ target_ssh_user | default('ansible-user') }}
          - Clave privada: {{ ssh_private_key_path | default('/home/ec2-user/keyPairLNX-Shared.pem') }}
          - Modo: Sin privilegios sudo
          
          LIMITACIONES:
          - Acceso limitado a m√©tricas del sistema
          - No se pudieron verificar todos los servicios
          - Acceso restringido a logs del sistema
          
          RECOMENDACI√ìN:
          Para acceso completo, configurar el usuario ansible-user en sudoers sin contrase√±a
          
          Automatizaci√≥n ejecutada por Ansible AWX
          Playbook: linux-server-check-universal-v5-mejorado.yml
        dest: "/tmp/automation_nosudo_{{ normalized_vars.source }}_{{ dynatrace_problem_id }}_{{ ansible_date_time.epoch | default('unknown') }}.txt"
      ignore_errors: yes
      
    - name: "Mostrar ubicaci√≥n del reporte y configuraci√≥n"
      debug:
        msg: |
          üìÑ ARCHIVO DE REPORTE CREADO:
          Ubicaci√≥n: /tmp/automation_nosudo_{{ normalized_vars.source }}_{{ dynatrace_problem_id }}_{{ ansible_date_time.epoch | default('unknown') }}.txt
          Fuente: {{ normalized_vars.source | upper }}
          Host Verificado: {{ normalized_vars.host_name }} ‚úÖ
          Modo: SIN SUDO ‚ö†Ô∏è
          
          üí° PARA ACCEDER AL ARCHIVO:
          cat /tmp/automation_nosudo_{{ normalized_vars.source }}_{{ dynatrace_problem_id }}_*.txt
          
          üîß CONFIGURACI√ìN PARA ACCESO COMPLETO:
          Para habilitar sudo sin contrase√±a, ejecutar en el host objetivo:
          echo "ansible-user ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/ansible-user
          
          üéØ CONFIRMACI√ìN: El playbook se ejecut√≥ correctamente en el host remoto {{ normalized_vars.host_name }} ({{ normalized_vars.host_ip }})
          ‚úÖ Usando clave SSH: {{ ssh_private_key_path | default('/home/ec2-user/keyPairLNX-Shared.pem') }}
          
          üìä RESUMEN EJECUTIVO:
          {% if "'RESUELTO'" in (hostvars[normalized_vars.host_name]['problem_analysis_result']['stdout'] | default('')) %}
          - Estado: PROBLEMA APARENTEMENTE RESUELTO ‚úÖ
          - Acci√≥n: MONITOREO PREVENTIVO recomendado
          {% else %}
          - Estado: REQUIERE INVESTIGACI√ìN ADICIONAL ‚ö†Ô∏è  
          - Acci√≥n: ESCALAMIENTO recomendado
          {% endif %}
          - Diagn√≥stico: COMPLETO (con limitaciones sin sudo)
          - Conectividad: EXITOSA